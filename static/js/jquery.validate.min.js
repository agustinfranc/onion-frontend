/*! jQuery Validation Plugin - v1.11.1 - 3/22/2013\n* https://github.com/jzaefferer/jquery-validation
 * Copyright (c) 2013 JÃ¶rn Zaefferer; Licensed MIT */ ;(function (t) {
  t.extend(t.fn, {
    validate(e) {
      if (!this.length)
        return (
          e &&
            e.debug &&
            window.console &&
            console.warn(
              "Nothing selected, can't validate, returning nothing."
            ),
          void 0
        )
      let i = t.data(this[0], 'validator')
      return (
        i ||
        (this.attr('novalidate', 'novalidate'),
        (i = new t.validator(e, this[0])),
        t.data(this[0], 'validator', i),
        i.settings.onsubmit &&
          (this.validateDelegate(':submit', 'click', function (e) {
            i.settings.submitHandler && (i.submitButton = e.target),
              t(e.target).hasClass('cancel') && (i.cancelSubmit = !0),
              void 0 !== t(e.target).attr('formnovalidate') &&
                (i.cancelSubmit = !0)
          }),
          this.submit(function (e) {
            function s() {
              let s
              return i.settings.submitHandler
                ? (i.submitButton &&
                    (s = t("<input type='hidden'/>")
                      .attr('name', i.submitButton.name)
                      .val(t(i.submitButton).val())
                      .appendTo(i.currentForm)),
                  i.settings.submitHandler.call(i, i.currentForm, e),
                  i.submitButton && s.remove(),
                  !1)
                : !0
            }
            return (
              i.settings.debug && e.preventDefault(),
              i.cancelSubmit
                ? ((i.cancelSubmit = !1), s())
                : i.form()
                ? i.pendingRequest
                  ? ((i.formSubmitted = !0), !1)
                  : s()
                : (i.focusInvalid(), !1)
            )
          })),
        i)
      )
    },
    valid() {
      if (t(this[0]).is('form')) return this.validate().form()
      let e = !0
      const i = t(this[0].form).validate()
      return (
        this.each(function () {
          e = e && i.element(this)
        }),
        e
      )
    },
    removeAttrs(e) {
      const i = {}
      const s = this
      return (
        t.each(e.split(/\s/), function (t, e) {
          ;(i[e] = s.attr(e)), s.removeAttr(e)
        }),
        i
      )
    },
    rules(e, i) {
      const s = this[0]
      if (e) {
        const r = t.data(s.form, 'validator').settings
        const n = r.rules
        const a = t.validator.staticRules(s)
        switch (e) {
          case 'add':
            t.extend(a, t.validator.normalizeRule(i)),
              delete a.messages,
              (n[s.name] = a),
              i.messages &&
                (r.messages[s.name] = t.extend(r.messages[s.name], i.messages))
            break
          case 'remove':
            if (!i) return delete n[s.name], a
            var u = {}
            return (
              t.each(i.split(/\s/), function (t, e) {
                ;(u[e] = a[e]), delete a[e]
              }),
              u
            )
        }
      }
      let o = t.validator.normalizeRules(
        t.extend(
          {},
          t.validator.classRules(s),
          t.validator.attributeRules(s),
          t.validator.dataRules(s),
          t.validator.staticRules(s)
        ),
        s
      )
      if (o.required) {
        const l = o.required
        delete o.required, (o = t.extend({ required: l }, o))
      }
      return o
    },
  }),
    t.extend(t.expr[':'], {
      blank(e) {
        return !t.trim('' + t(e).val())
      },
      filled(e) {
        return !!t.trim('' + t(e).val())
      },
      unchecked(e) {
        return !t(e).prop('checked')
      },
    }),
    (t.validator = function (e, i) {
      ;(this.settings = t.extend(!0, {}, t.validator.defaults, e)),
        (this.currentForm = i),
        this.init()
    }),
    (t.validator.format = function (e, i) {
      return arguments.length === 1
        ? function () {
            const i = t.makeArray(arguments)
            return i.unshift(e), t.validator.format.apply(this, i)
          }
        : (arguments.length > 2 &&
            i.constructor !== Array &&
            (i = t.makeArray(arguments).slice(1)),
          i.constructor !== Array && (i = [i]),
          t.each(i, function (t, i) {
            e = e.replace(RegExp('\\{' + t + '\\}', 'g'), function () {
              return i
            })
          }),
          e)
    }),
    t.extend(t.validator, {
      defaults: {
        messages: {},
        groups: {},
        rules: {},
        errorClass: 'error',
        validClass: 'valid',
        errorElement: 'label',
        focusInvalid: !0,
        errorContainer: t([]),
        errorLabelContainer: t([]),
        onsubmit: !0,
        ignore: ':hidden',
        ignoreTitle: !1,
        onfocusin(t) {
          ;(this.lastActive = t),
            this.settings.focusCleanup &&
              !this.blockFocusCleanup &&
              (this.settings.unhighlight &&
                this.settings.unhighlight.call(
                  this,
                  t,
                  this.settings.errorClass,
                  this.settings.validClass
                ),
              this.addWrapper(this.errorsFor(t)).hide())
        },
        onfocusout(t) {
          this.checkable(t) ||
            (!(t.name in this.submitted) && this.optional(t)) ||
            this.element(t)
        },
        onkeyup(t, e) {
          ;(e.which !== 9 || this.elementValue(t) !== '') &&
            (t.name in this.submitted || t === this.lastElement) &&
            this.element(t)
        },
        onclick(t) {
          t.name in this.submitted
            ? this.element(t)
            : t.parentNode.name in this.submitted && this.element(t.parentNode)
        },
        highlight(e, i, s) {
          e.type === 'radio'
            ? this.findByName(e.name).addClass(i).removeClass(s)
            : t(e).addClass(i).removeClass(s)
        },
        unhighlight(e, i, s) {
          e.type === 'radio'
            ? this.findByName(e.name).removeClass(i).addClass(s)
            : t(e).removeClass(i).addClass(s)
        },
      },
      setDefaults(e) {
        t.extend(t.validator.defaults, e)
      },
      messages: {
        required: 'This field is required.',
        remote: 'Please fix this field.',
        email: 'Please enter a valid email address.',
        url: 'Please enter a valid URL.',
        date: 'Please enter a valid date.',
        dateISO: 'Please enter a valid date (ISO).',
        number: 'Please enter a valid number.',
        digits: 'Please enter only digits.',
        creditcard: 'Please enter a valid credit card number.',
        equalTo: 'Please enter the same value again.',
        maxlength: t.validator.format(
          'Please enter no more than {0} characters.'
        ),
        minlength: t.validator.format('Please enter at least {0} characters.'),
        rangelength: t.validator.format(
          'Please enter a value between {0} and {1} characters long.'
        ),
        range: t.validator.format('Please enter a value between {0} and {1}.'),
        max: t.validator.format(
          'Please enter a value less than or equal to {0}.'
        ),
        min: t.validator.format(
          'Please enter a value greater than or equal to {0}.'
        ),
      },
      autoCreateRanges: !1,
      prototype: {
        init() {
          function e(e) {
            const i = t.data(this[0].form, 'validator')
            const s = 'on' + e.type.replace(/^validate/, '')
            i.settings[s] && i.settings[s].call(i, this[0], e)
          }
          ;(this.labelContainer = t(this.settings.errorLabelContainer)),
            (this.errorContext =
              (this.labelContainer.length && this.labelContainer) ||
              t(this.currentForm)),
            (this.containers = t(this.settings.errorContainer).add(
              this.settings.errorLabelContainer
            )),
            (this.submitted = {}),
            (this.valueCache = {}),
            (this.pendingRequest = 0),
            (this.pending = {}),
            (this.invalid = {}),
            this.reset()
          const i = (this.groups = {})
          t.each(this.settings.groups, function (e, s) {
            typeof s === 'string' && (s = s.split(/\s/)),
              t.each(s, function (t, s) {
                i[s] = e
              })
          })
          const s = this.settings.rules
          t.each(s, function (e, i) {
            s[e] = t.validator.normalizeRule(i)
          }),
            t(this.currentForm)
              .validateDelegate(
                ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'] ,[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'] ",
                'focusin focusout keyup',
                e
              )
              .validateDelegate(
                "[type='radio'], [type='checkbox'], select, option",
                'click',
                e
              ),
            this.settings.invalidHandler &&
              t(this.currentForm).bind(
                'invalid-form.validate',
                this.settings.invalidHandler
              )
        },
        form() {
          return (
            this.checkForm(),
            t.extend(this.submitted, this.errorMap),
            (this.invalid = t.extend({}, this.errorMap)),
            this.valid() ||
              t(this.currentForm).triggerHandler('invalid-form', [this]),
            this.showErrors(),
            this.valid()
          )
        },
        checkForm() {
          this.prepareForm()
          for (
            let t = 0, e = (this.currentElements = this.elements());
            e[t];
            t++
          )
            this.check(e[t])
          return this.valid()
        },
        element(e) {
          ;(e = this.validationTargetFor(this.clean(e))),
            (this.lastElement = e),
            this.prepareElement(e),
            (this.currentElements = t(e))
          const i = this.check(e) !== !1
          return (
            i ? delete this.invalid[e.name] : (this.invalid[e.name] = !0),
            this.numberOfInvalids() ||
              (this.toHide = this.toHide.add(this.containers)),
            this.showErrors(),
            i
          )
        },
        showErrors(e) {
          if (e) {
            t.extend(this.errorMap, e), (this.errorList = [])
            for (const i in e)
              this.errorList.push({
                message: e[i],
                element: this.findByName(i)[0],
              })
            this.successList = t.grep(this.successList, function (t) {
              return !(t.name in e)
            })
          }
          this.settings.showErrors
            ? this.settings.showErrors.call(this, this.errorMap, this.errorList)
            : this.defaultShowErrors()
        },
        resetForm() {
          t.fn.resetForm && t(this.currentForm).resetForm(),
            (this.submitted = {}),
            (this.lastElement = null),
            this.prepareForm(),
            this.hideErrors(),
            this.elements()
              .removeClass(this.settings.errorClass)
              .removeData('previousValue')
        },
        numberOfInvalids() {
          return this.objectLength(this.invalid)
        },
        objectLength(t) {
          let e = 0
          for (const i in t) e++
          return e
        },
        hideErrors() {
          this.addWrapper(this.toHide).hide()
        },
        valid() {
          return this.size() === 0
        },
        size() {
          return this.errorList.length
        },
        focusInvalid() {
          if (this.settings.focusInvalid)
            try {
              t(
                this.findLastActive() ||
                  (this.errorList.length && this.errorList[0].element) ||
                  []
              )
                .filter(':visible')
                .focus()
                .trigger('focusin')
            } catch (e) {}
        },
        findLastActive() {
          const e = this.lastActive
          return (
            e &&
            t.grep(this.errorList, function (t) {
              return t.element.name === e.name
            }).length === 1 &&
            e
          )
        },
        elements() {
          const e = this
          const i = {}
          return t(this.currentForm)
            .find('input, select, textarea')
            .not(':submit, :reset, :image, [disabled]')
            .not(this.settings.ignore)
            .filter(function () {
              return (
                !this.name &&
                  e.settings.debug &&
                  window.console &&
                  console.error('%o has no name assigned', this),
                this.name in i || !e.objectLength(t(this).rules())
                  ? !1
                  : ((i[this.name] = !0), !0)
              )
            })
        },
        clean(e) {
          return t(e)[0]
        },
        errors() {
          const e = this.settings.errorClass.replace(' ', '.')
          return t(this.settings.errorElement + '.' + e, this.errorContext)
        },
        reset() {
          ;(this.successList = []),
            (this.errorList = []),
            (this.errorMap = {}),
            (this.toShow = t([])),
            (this.toHide = t([])),
            (this.currentElements = t([]))
        },
        prepareForm() {
          this.reset(), (this.toHide = this.errors().add(this.containers))
        },
        prepareElement(t) {
          this.reset(), (this.toHide = this.errorsFor(t))
        },
        elementValue(e) {
          const i = t(e).attr('type')
          const s = t(e).val()
          return i === 'radio' || i === 'checkbox'
            ? t("input[name='" + t(e).attr('name') + "']:checked").val()
            : typeof s === 'string'
            ? s.replace(/\r/g, '')
            : s
        },
        check(e) {
          e = this.validationTargetFor(this.clean(e))
          let i
          const s = t(e).rules()
          let r = !1
          const n = this.elementValue(e)
          for (const a in s) {
            const u = { method: a, parameters: s[a] }
            try {
              if (
                ((i = t.validator.methods[a].call(this, n, e, u.parameters)),
                i === 'dependency-mismatch')
              ) {
                r = !0
                continue
              }
              if (((r = !1), i === 'pending'))
                return (
                  (this.toHide = this.toHide.not(this.errorsFor(e))), void 0
                )
              if (!i) return this.formatAndAdd(e, u), !1
            } catch (o) {
              throw (
                (this.settings.debug &&
                  window.console &&
                  console.log(
                    'Exception occurred when checking element ' +
                      e.id +
                      ", check the '" +
                      u.method +
                      "' method.",
                    o
                  ),
                o)
              )
            }
          }
          return r
            ? void 0
            : (this.objectLength(s) && this.successList.push(e), !0)
        },
        customDataMessage(e, i) {
          return (
            t(e).data('msg-' + i.toLowerCase()) ||
            (e.attributes && t(e).attr('data-msg-' + i.toLowerCase()))
          )
        },
        customMessage(t, e) {
          const i = this.settings.messages[t]
          return i && (i.constructor === String ? i : i[e])
        },
        findDefined() {
          for (let t = 0; arguments.length > t; t++)
            if (void 0 !== arguments[t]) return arguments[t]
          return void 0
        },
        defaultMessage(e, i) {
          return this.findDefined(
            this.customMessage(e.name, i),
            this.customDataMessage(e, i),
            (!this.settings.ignoreTitle && e.title) || void 0,
            t.validator.messages[i],
            '<strong>Warning: No message defined for ' + e.name + '</strong>'
          )
        },
        formatAndAdd(e, i) {
          let s = this.defaultMessage(e, i.method)
          const r = /\$?\{(\d+)\}/g
          typeof s === 'function'
            ? (s = s.call(this, i.parameters, e))
            : r.test(s) &&
              (s = t.validator.format(s.replace(r, '{$1}'), i.parameters)),
            this.errorList.push({ message: s, element: e }),
            (this.errorMap[e.name] = s),
            (this.submitted[e.name] = s)
        },
        addWrapper(t) {
          return (
            this.settings.wrapper &&
              (t = t.add(t.parent(this.settings.wrapper))),
            t
          )
        },
        defaultShowErrors() {
          let t, e
          for (t = 0; this.errorList[t]; t++) {
            const i = this.errorList[t]
            this.settings.highlight &&
              this.settings.highlight.call(
                this,
                i.element,
                this.settings.errorClass,
                this.settings.validClass
              ),
              this.showLabel(i.element, i.message)
          }
          if (
            (this.errorList.length &&
              (this.toShow = this.toShow.add(this.containers)),
            this.settings.success)
          )
            for (t = 0; this.successList[t]; t++)
              this.showLabel(this.successList[t])
          if (this.settings.unhighlight)
            for (t = 0, e = this.validElements(); e[t]; t++)
              this.settings.unhighlight.call(
                this,
                e[t],
                this.settings.errorClass,
                this.settings.validClass
              )
          ;(this.toHide = this.toHide.not(this.toShow)),
            this.hideErrors(),
            this.addWrapper(this.toShow).show()
        },
        validElements() {
          return this.currentElements.not(this.invalidElements())
        },
        invalidElements() {
          return t(this.errorList).map(function () {
            return this.element
          })
        },
        showLabel(e, i) {
          let s = this.errorsFor(e)
          s.length
            ? (s
                .removeClass(this.settings.validClass)
                .addClass(this.settings.errorClass),
              s.html(i))
            : ((s = t('<' + this.settings.errorElement + '>')
                .attr('for', this.idOrName(e))
                .addClass(this.settings.errorClass)
                .html(i || '')),
              this.settings.wrapper &&
                (s = s
                  .hide()
                  .show()
                  .wrap('<' + this.settings.wrapper + '/>')
                  .parent()),
              this.labelContainer.append(s).length ||
                (this.settings.errorPlacement
                  ? this.settings.errorPlacement(s, t(e))
                  : s.insertAfter(e))),
            !i &&
              this.settings.success &&
              (s.text(''),
              typeof this.settings.success === 'string'
                ? s.addClass(this.settings.success)
                : this.settings.success(s, e)),
            (this.toShow = this.toShow.add(s))
        },
        errorsFor(e) {
          const i = this.idOrName(e)
          return this.errors().filter(function () {
            return t(this).attr('for') === i
          })
        },
        idOrName(t) {
          return (
            this.groups[t.name] || (this.checkable(t) ? t.name : t.id || t.name)
          )
        },
        validationTargetFor(t) {
          return (
            this.checkable(t) &&
              (t = this.findByName(t.name).not(this.settings.ignore)[0]),
            t
          )
        },
        checkable(t) {
          return /radio|checkbox/i.test(t.type)
        },
        findByName(e) {
          return t(this.currentForm).find("[name='" + e + "']")
        },
        getLength(e, i) {
          switch (i.nodeName.toLowerCase()) {
            case 'select':
              return t('option:selected', i).length
            case 'input':
              if (this.checkable(i))
                return this.findByName(i.name).filter(':checked').length
          }
          return e.length
        },
        depend(t, e) {
          return this.dependTypes[typeof t]
            ? this.dependTypes[typeof t](t, e)
            : !0
        },
        dependTypes: {
          boolean(t) {
            return t
          },
          string(e, i) {
            return !!t(e, i.form).length
          },
          function(t, e) {
            return t(e)
          },
        },
        optional(e) {
          const i = this.elementValue(e)
          return (
            !t.validator.methods.required.call(this, i, e) &&
            'dependency-mismatch'
          )
        },
        startRequest(t) {
          this.pending[t.name] ||
            (this.pendingRequest++, (this.pending[t.name] = !0))
        },
        stopRequest(e, i) {
          this.pendingRequest--,
            this.pendingRequest < 0 && (this.pendingRequest = 0),
            delete this.pending[e.name],
            i && this.pendingRequest === 0 && this.formSubmitted && this.form()
              ? (t(this.currentForm).submit(), (this.formSubmitted = !1))
              : !i &&
                this.pendingRequest === 0 &&
                this.formSubmitted &&
                (t(this.currentForm).triggerHandler('invalid-form', [this]),
                (this.formSubmitted = !1))
        },
        previousValue(e) {
          return (
            t.data(e, 'previousValue') ||
            t.data(e, 'previousValue', {
              old: null,
              valid: !0,
              message: this.defaultMessage(e, 'remote'),
            })
          )
        },
      },
      classRuleSettings: {
        required: { required: !0 },
        email: { email: !0 },
        url: { url: !0 },
        date: { date: !0 },
        dateISO: { dateISO: !0 },
        number: { number: !0 },
        digits: { digits: !0 },
        creditcard: { creditcard: !0 },
      },
      addClassRules(e, i) {
        e.constructor === String
          ? (this.classRuleSettings[e] = i)
          : t.extend(this.classRuleSettings, e)
      },
      classRules(e) {
        const i = {}
        const s = t(e).attr('class')
        return (
          s &&
            t.each(s.split(' '), function () {
              this in t.validator.classRuleSettings &&
                t.extend(i, t.validator.classRuleSettings[this])
            }),
          i
        )
      },
      attributeRules(e) {
        const i = {}
        const s = t(e)
        const r = s[0].getAttribute('type')
        for (const n in t.validator.methods) {
          var a
          n === 'required'
            ? ((a = s.get(0).getAttribute(n)), a === '' && (a = !0), (a = !!a))
            : (a = s.attr(n)),
            /min|max/.test(n) &&
              (r === null || /number|range|text/.test(r)) &&
              (a = Number(a)),
            a ? (i[n] = a) : r === n && r !== 'range' && (i[n] = !0)
        }
        return (
          i.maxlength &&
            /-1|2147483647|524288/.test(i.maxlength) &&
            delete i.maxlength,
          i
        )
      },
      dataRules(e) {
        let i
        let s
        const r = {}
        const n = t(e)
        for (i in t.validator.methods)
          (s = n.data('rule-' + i.toLowerCase())), void 0 !== s && (r[i] = s)
        return r
      },
      staticRules(e) {
        let i = {}
        const s = t.data(e.form, 'validator')
        return (
          s.settings.rules &&
            (i = t.validator.normalizeRule(s.settings.rules[e.name]) || {}),
          i
        )
      },
      normalizeRules(e, i) {
        return (
          t.each(e, function (s, r) {
            if (r === !1) return delete e[s], void 0
            if (r.param || r.depends) {
              let n = !0
              switch (typeof r.depends) {
                case 'string':
                  n = !!t(r.depends, i.form).length
                  break
                case 'function':
                  n = r.depends.call(i, i)
              }
              n ? (e[s] = void 0 !== r.param ? r.param : !0) : delete e[s]
            }
          }),
          t.each(e, function (s, r) {
            e[s] = t.isFunction(r) ? r(i) : r
          }),
          t.each(['minlength', 'maxlength'], function () {
            e[this] && (e[this] = Number(e[this]))
          }),
          t.each(['rangelength', 'range'], function () {
            let i
            e[this] &&
              (t.isArray(e[this])
                ? (e[this] = [Number(e[this][0]), Number(e[this][1])])
                : typeof e[this] === 'string' &&
                  ((i = e[this].split(/[\s,]+/)),
                  (e[this] = [Number(i[0]), Number(i[1])])))
          }),
          t.validator.autoCreateRanges &&
            (e.min &&
              e.max &&
              ((e.range = [e.min, e.max]), delete e.min, delete e.max),
            e.minlength &&
              e.maxlength &&
              ((e.rangelength = [e.minlength, e.maxlength]),
              delete e.minlength,
              delete e.maxlength)),
          e
        )
      },
      normalizeRule(e) {
        if (typeof e === 'string') {
          const i = {}
          t.each(e.split(/\s/), function () {
            i[this] = !0
          }),
            (e = i)
        }
        return e
      },
      addMethod(e, i, s) {
        ;(t.validator.methods[e] = i),
          (t.validator.messages[e] =
            void 0 !== s ? s : t.validator.messages[e]),
          i.length < 3 &&
            t.validator.addClassRules(e, t.validator.normalizeRule(e))
      },
      methods: {
        required(e, i, s) {
          if (!this.depend(s, i)) return 'dependency-mismatch'
          if (i.nodeName.toLowerCase() === 'select') {
            const r = t(i).val()
            return r && r.length > 0
          }
          return this.checkable(i)
            ? this.getLength(e, i) > 0
            : t.trim(e).length > 0
        },
        email(t, e) {
          return (
            this.optional(e) ||
            /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0D\x0A))?(\x20|\x09)+)?(([\x01-\x08\x0B\x0C\x0E-\x1F\x7F]|\x21|[\x23-\x5B]|[\x5D-\x7E]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0B\x0C\x0D-\x7F]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0D\x0A))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(
              t
            )
          )
        },
        url(t, e) {
          return (
            this.optional(e) ||
            /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(
              t
            )
          )
        },
        date(t, e) {
          return this.optional(e) || !/Invalid|NaN/.test('' + new Date(t))
        },
        dateISO(t, e) {
          return this.optional(e) || /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/.test(t)
        },
        number(t, e) {
          return (
            this.optional(e) ||
            /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(t)
          )
        },
        digits(t, e) {
          return this.optional(e) || /^\d+$/.test(t)
        },
        creditcard(t, e) {
          if (this.optional(e)) return 'dependency-mismatch'
          if (/[^0-9 \-]+/.test(t)) return !1
          let i = 0
          let s = 0
          let r = !1
          t = t.replace(/\D/g, '')
          for (let n = t.length - 1; n >= 0; n--) {
            const a = t.charAt(n)
            ;(s = parseInt(a, 10)),
              r && (s *= 2) > 9 && (s -= 9),
              (i += s),
              (r = !r)
          }
          return i % 10 === 0
        },
        minlength(e, i, s) {
          const r = t.isArray(e) ? e.length : this.getLength(t.trim(e), i)
          return this.optional(i) || r >= s
        },
        maxlength(e, i, s) {
          const r = t.isArray(e) ? e.length : this.getLength(t.trim(e), i)
          return this.optional(i) || s >= r
        },
        rangelength(e, i, s) {
          const r = t.isArray(e) ? e.length : this.getLength(t.trim(e), i)
          return this.optional(i) || (r >= s[0] && s[1] >= r)
        },
        min(t, e, i) {
          return this.optional(e) || t >= i
        },
        max(t, e, i) {
          return this.optional(e) || i >= t
        },
        range(t, e, i) {
          return this.optional(e) || (t >= i[0] && i[1] >= t)
        },
        equalTo(e, i, s) {
          const r = t(s)
          return (
            this.settings.onfocusout &&
              r
                .unbind('.validate-equalTo')
                .bind('blur.validate-equalTo', function () {
                  t(i).valid()
                }),
            e === r.val()
          )
        },
        remote(e, i, s) {
          if (this.optional(i)) return 'dependency-mismatch'
          const r = this.previousValue(i)
          if (
            (this.settings.messages[i.name] ||
              (this.settings.messages[i.name] = {}),
            (r.originalMessage = this.settings.messages[i.name].remote),
            (this.settings.messages[i.name].remote = r.message),
            (s = (typeof s === 'string' && { url: s }) || s),
            r.old === e)
          )
            return r.valid
          r.old = e
          const n = this
          this.startRequest(i)
          const a = {}
          return (
            (a[i.name] = e),
            t.ajax(
              t.extend(
                !0,
                {
                  url: s,
                  mode: 'abort',
                  port: 'validate' + i.name,
                  dataType: 'json',
                  data: a,
                  success(s) {
                    n.settings.messages[i.name].remote = r.originalMessage
                    const a = s === !0 || s === 'true'
                    if (a) {
                      const u = n.formSubmitted
                      n.prepareElement(i),
                        (n.formSubmitted = u),
                        n.successList.push(i),
                        delete n.invalid[i.name],
                        n.showErrors()
                    } else {
                      const o = {}
                      const l = s || n.defaultMessage(i, 'remote')
                      ;(o[i.name] = r.message = t.isFunction(l) ? l(e) : l),
                        (n.invalid[i.name] = !0),
                        n.showErrors(o)
                    }
                    ;(r.valid = a), n.stopRequest(i, a)
                  },
                },
                s
              )
            ),
            'pending'
          )
        },
      },
    }),
    (t.format = t.validator.format)
})(jQuery),
  (function (t) {
    const e = {}
    if (t.ajaxPrefilter)
      t.ajaxPrefilter(function (t, i, s) {
        const r = t.port
        t.mode === 'abort' && (e[r] && e[r].abort(), (e[r] = s))
      })
    else {
      const i = t.ajax
      t.ajax = function (s) {
        const r = ('mode' in s ? s : t.ajaxSettings).mode
        const n = ('port' in s ? s : t.ajaxSettings).port
        return r === 'abort'
          ? (e[n] && e[n].abort(), (e[n] = i.apply(this, arguments)), e[n])
          : i.apply(this, arguments)
      }
    }
  })(jQuery),
  (function (t) {
    t.extend(t.fn, {
      validateDelegate(e, i, s) {
        return this.bind(i, function (i) {
          const r = t(i.target)
          return r.is(e) ? s.apply(r, arguments) : void 0
        })
      },
    })
  })(jQuery)
